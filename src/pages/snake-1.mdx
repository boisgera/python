---
context:
title: The Snake Game
description: Don't you think that it's only appropriate to discover Python with a snake game?
date: "2023-09-06 11:00"
authors: 
  - name: S√©bastien Boisg√©rault
    title: Associate Professor
    email: Sebastien.Boisgerault@minesparis.psl.eu 
    url: https://eul.ink
    image: https://2.gravatar.com/avatar/39ec5d637b0753448b97a8e63855a45cb6708d033b656fe9f1d3314bb4bfb202?size=128
    affiliation: ITN Mines Paris ‚Äì PSL
    twitter: "boisgera"
    github: "boisgera"
    linkedin: "S√©bastien Boisg√©rault"
tags: [Python, pyxel, game, snake]
license: "CC BY 4.0"
layout: ../layouts/MDXLayout.astro
---

export const debug = false;

import Admonition from "/src/components/Admonition.astro";
import Header from "/src/components/Header.astro";
import { Image } from "astro:assets";

<Header frontmatter={frontmatter}/>

import snake from "/src/assets/snake.jpg";

<Image transition:name="snakeImage" src={snake} alt="Boa constrictor by Jan Kop≈ôiva" style="border-radius: 0.375rem;"/>


<Admonition type="note" title="Attribution" open={true} lock>
The first version of this project was authored by Aur√©lien Noce (aka [@ushu](https://github.com/ushu)).
</Admonition>


## Introduction


This project you will develop a simple game in Python.
This is meant to be an introduction to the design and implementation
of a complete program.

The subject is a standard of video games, the üêç [snake] game!
Many variants of this game exist; [slither.io] is a good
example of a modernized snake (and notably, massively multiplayer !).

Don't be afraid, our objectives will be modest and therefore close to the
classic version of the game: we will develop several versions of a
**working program** (and not a perfect program) whose features will be
enriched at each new step.

Here is the kind of things that we expect to have at the end:

**TODO**

[snake]: https://en.wikipedia.org/wiki/Snake_(video_game_genre)
[slither.io]: https://slither.io

## Getting started

Let's start with a message display whose color changes over time.

<video controls width="768">
  <source src="../videos/hello-snake.webm" type="video/webm" />
</video>

The code of this application is:

```python
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(0)
    color = pyxel.frame_count % 16
    pyxel.text(56, 54, "Hello, Snake!", color)

pyxel.init(160, 120)
pyxel.run(update, draw)
```

Now we are going to slightly tweak this program until we understand 
what's going on. 
When it's necessary, search into Pyxel's [user's guide] and [reference 
documentation].

[user's guide]: https://github.com/kitao/pyxel#how-to-uses
[reference documentation]: https://github.com/kitao/pyxel#api-reference


import palette from "/src/assets/pyxel-color-palette.png";

### Colors

Can you display the message in black on a white background instead?



<Admonition type="solution" open={debug}>
In the spirit of retro gaming, Pyxel can only display 16 colors.
The standard palette from which you must pick your color is described [here][palette].

<Image src={palette} alt="Pyxel's color palette" style="margin:auto;display:block;"/>


The index of black is `0` and there is no pure white, but the closest is color
`7`. 
Therefore, the changes we need to perform are:

[palette]: https://github.com/kitao/pyxel#color-palette


```python
def draw():
    pyxel.cls(7)
    pyxel.text(56, 54, "Hello, Snake!", 1)
```
</Admonition>

[API]: https://github.com/kitao/pyxel#api-reference

### Text & Geometry

- Text: comprendre la taille (fixe) de chaque caract√®re,
  display d'une "grille" de caract√®res., comprendre comment est
  plac√© le "Hello world!", ajuster le programme pour que le texte
  soit toujours centr√© (m√™me si plusieurs lignes ?).

- Message translating from the right to the left?

### Frame rate

The `time` function from the `time` module of the Python standard library
returns the time elapsed in seconds since January 1st, 1970 at noon.

```
>>> import time
>>> time.time()
1692980870.0990813
>>> time.time()
1692980871.2445116
>>> time.time()
1692980872.3245282
```

Use this function to measure the time elapsed between two calls to the `draw`
function of Pyxel. Then, print the (approximate) number of frames per second 
(FPS) in window top left corner.

<video controls width="768">
  <source src="../videos/fps.webm" type="video/webm" />
</video>

<Admonition type="solution" open={debug}>
```python
import pyxel
import time

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    global t
    t_new = time.time()
    dt = t_new - t
    t = t_new
    fps = 1.0 / dt
    fps = int(round(fps))
    pyxel.cls(0)
    color = pyxel.frame_count % 16
    pyxel.text(56, 54, "Hello, Snake!", color)
    pyxel.text(0, 0, f"fps: {fps}", 7)
```
</Admonition>

## The Game Board

Let's build a game board

- made of a square of 30x30 cells,

- with each cell is 1 pixel large.

<Admonition type="question" title="Don't you think that 1 pixel is too small?">
Yes, it certainly would be if we were talking about real pixels! 
But luckily for us, Pyxel automatically scales the display to fit the screen size. 
Since we use a small display, it will zoom it quite a bit and we will be able to see every "pixel" clearly.
</Admonition>

To check that everything's ok, draw a checkerboard pattern like this:

import checkerboard from "/src/assets/checkerboard.png";

<Image src={checkerboard} alt="A 30x30 checkerboard" />

We will keep this checkerboard in the background as "training wheels" for a 
while, and remove it at the very last step.

<Admonition type="solution" open={debug}>
```python
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(13)
    for i in range(30):
        for j in range(30):
            if (i+j) % 2 == 0:
                pyxel.pset(i, j, 7)

pyxel.init(30, 30)
pyxel.run(update, draw)
```
</Admonition>

## The (Forbidden) Fruit

Display a fruit at a random location on top of the checkerboard.
A fruit is a simple 1x1 rectangle (a pixel!). Pick a color you like !
When we say "random", we want the fruit location to be different each time
you restart the program.


import fruit from "/src/assets/fruit.png";

<Image src={fruit} alt="A fruit at a random location" />

<Admonition type="solution" open={debug}>
```python
import pyxel 

pyxel.init(30, 30)

fruit = [
    pyxel.rndi(0, 29), 
    pyxel.rndi(0, 29)
]

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(13)
    for i in range(30):
        for j in range(30):
            if (i+j) % 2 == 0:
                pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)

pyxel.run(update, draw)
```
</Admonition>

## A Restin' Snake

In the next step, we will represent the snake, as a sequence of pixels.
Let's snake with the following simple sequence

```python
snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]
```

Let's say that `[12, 15]` is the snake head.
Use a dark green color to represent the snake body and a light green 
for its head.


import restingSnake from "/src/assets/resting-snake.png";

<Image src={restingSnake} alt="A resting snake" />


<Admonition type="solution" open={debug} >

```python
import pyxel

pyxel.init(30, 30)

fruit = [
    pyxel.rndi(0, 29), 
    pyxel.rndi(0, 29)
]

snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(7)
    for i in range(30):
        pyxel.cls(13)
        for j in range(30):
            if (i+j) % 2 == 0:
                pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.run(update, draw)
```
</Admonition>

## Events

**TODO.** Checkerboard off by default, on/off with "C" key

<video controls width="768">
  <source src="../videos/checkerboard-on-off.webm" type="video/webm" />
</video>


<Admonition type="solution" open={debug} >

```python
import pyxel

pyxel.init(30, 30)

fruit = [
    pyxel.rndi(0, 29), 
    pyxel.rndi(0, 29)
]

snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]

checkerboard = False

def update():
    global checkerboard
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    if pyxel.btnp(pyxel.KEY_C):
        checkerboard = not checkerboard

def draw():
    pyxel.cls(7)
    if checkerboard:
        pyxel.cls(13)
        for i in range(30):
            for j in range(30):
                if (i+j) % 2 == 0:
                    pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.run(update, draw)
```
</Admonition>

**TODO.** Modify the program so that when the user presses the arrow keys,
the program displays (with the `print` function) the characters `‚Üê`, `‚Üë`, `‚Üí`
or `‚Üì` in the terminal.


<Admonition type="solution" open={debug}>

```python
import pyxel

pyxel.init(30, 30)

fruit = [
    pyxel.rndi(0, 29), 
    pyxel.rndi(0, 29)
]

snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]

checkerboard = False

arrow_keys = [
    pyxel.KEY_UP, 
    pyxel.KEY_DOWN, 
    pyxel.KEY_LEFT, 
    pyxel.KEY_RIGHT
]

def update():
    global checkerboard
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    if pyxel.btnp(pyxel.KEY_C):
        checkerboard = not checkerboard
    arrow_keys_pressed = []
    for key in arrow_keys:
        if pyxel.btnp(key):
            arrow_keys_pressed.append(key)
    for key in arrow_keys_pressed:
        if key == pyxel.KEY_UP:
            print("‚Üë")
        elif key == pyxel.KEY_DOWN:
            print("‚Üì")
        elif key == pyxel.KEY_LEFT:
            print("‚Üê")   
        elif key == pyxel.KEY_RIGHT:
            print("‚Üí")

def draw():
    pyxel.cls(7)
    if checkerboard:
        pyxel.cls(13)
        for i in range(30):
            for j in range(30):
                if (i+j) % 2 == 0:
                    pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.run(update, draw)
```
</Admonition>




## It's Aliiiiiiive!

We are finally going to make the snake move!

  - We create a direction vector, such as
 
    ```python
    snake_direction = [1, 0]
    ```

  - At each update, we move the head of the snake in this direction
    and the rest of its body follows.

  - Pressing an arrow key changes the direction of the snake.

  - Une fois que le serpent bouge, ajouter les commandes pour se d√©placer dans
les 4 directions, en appuyant sur les touches de direction du clavier.

<Admonition type="warning" title="üó≤ OMG it's so fast!">
You may consider slowing down the game at this point ... at least while you
are developing and testing it! Technically, you are searching to decrease the
frame rate. 
</Admonition>


<Admonition type="solution" open={debug}>
```python
import pyxel

pyxel.init(30, 30, fps=10)

fruit = [
    pyxel.rndi(0, 29), 
    pyxel.rndi(0, 29)
]

snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]

snake_direction = [1, 0]
 
checkerboard = False

arrow_keys = [
    pyxel.KEY_UP, 
    pyxel.KEY_DOWN, 
    pyxel.KEY_LEFT, 
    pyxel.KEY_RIGHT
]

def update():
    global checkerboard, snake_geometry, snake_direction
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    if pyxel.btnp(pyxel.KEY_C):
        checkerboard = not checkerboard
    arrow_keys_pressed = []
    for key in arrow_keys:
        if pyxel.btnp(key):
            arrow_keys_pressed.append(key)
    for key in arrow_keys_pressed:
        if key == pyxel.KEY_UP:
            snake_direction = [0, -1]
        elif key == pyxel.KEY_DOWN:
            snake_direction = [0, 1]
        elif key == pyxel.KEY_LEFT:
            snake_direction = [-1, 0]  
        elif key == pyxel.KEY_RIGHT:
            snake_direction = [1, 0]
    snake_head = snake_geometry[-1]
    new_snake_head = [
      snake_head[0] + snake_direction[0],
      snake_head[1] + snake_direction[1]
    ]
    snake_geometry = snake_geometry[1:] + [new_snake_head]

def draw():
    pyxel.cls(7)
    if checkerboard:
        pyxel.cls(13)
        for i in range(30):
            for j in range(30):
                if (i+j) % 2 == 0:
                    pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.run(update, draw)
```
</Admonition>


## I am starving!

So far the fruit and the snake don't interact.
Let's change that! Make sure that:

  - when the snake head reaches the fruit, the fruit disappears,

  - the snake grows by one pixel and

  - a new fruit appears at a random location.


<Admonition type="solution" open={debug}>
```python
import pyxel

pyxel.init(30, 30, fps=10)

fruit = None

def spawn_new_fruit():
    global fruit 
    fruit = [
        pyxel.rndi(0, 29), 
        pyxel.rndi(0, 29)
    ]

spawn_new_fruit()

snake_geometry = [
    [10, 15],
    [11, 15],
    [12, 15],
]

snake_direction = [1, 0]
 
checkerboard = False

arrow_keys = [
    pyxel.KEY_UP, 
    pyxel.KEY_DOWN, 
    pyxel.KEY_LEFT, 
    pyxel.KEY_RIGHT
]

def update():
    global checkerboard, snake_geometry, snake_direction
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    if pyxel.btnp(pyxel.KEY_C):
        checkerboard = not checkerboard
    arrow_keys_pressed = []
    for key in arrow_keys:
        if pyxel.btnp(key):
            arrow_keys_pressed.append(key)
    for key in arrow_keys_pressed:
        if key == pyxel.KEY_UP:
            snake_direction = [0, -1]
        elif key == pyxel.KEY_DOWN:
            snake_direction = [0, 1]
        elif key == pyxel.KEY_LEFT:
            snake_direction = [-1, 0]  
        elif key == pyxel.KEY_RIGHT:
            snake_direction = [1, 0]
    snake_head = snake_geometry[-1]
    new_snake_head = [
      snake_head[0] + snake_direction[0],
      snake_head[1] + snake_direction[1]
    ]
    if new_snake_head == fruit:
        snake_geometry = snake_geometry + [new_snake_head]
        spawn_new_fruit()
    else:
        snake_geometry = snake_geometry[1:] + [new_snake_head]

def draw():
    pyxel.cls(7)
    if checkerboard:
        pyxel.cls(13)
        for i in range(30):
            for j in range(30):
                if (i+j) % 2 == 0:
                    pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.run(update, draw)
```
</Admonition>

## Epilog

Obviously, there are a couple of things missing here.
To begin with, we need to detect if the snake head collides with its body or with
the walls, which is a failure condition and should stop the game.

It would also be nice to have a "splash screen" that greets us when we start 
the game and also to be able to restart it after we're dead!

Click the Pyxel logo below to play the final result!

<a href="../snake-game">
<img src="../pyxel_logo_152x64.png" width="152" height="64" 
style="margin-top:3rem; margin-bottom:3rem;"/>
</a>



<Admonition type="solution" open={debug}>
```python
import pyxel

def spawn_new_fruit():
    global fruit 
    fruit = [
        pyxel.rndi(0, 29), 
        pyxel.rndi(0, 29)
    ]

def spawn_new_snake():
    global snake_geometry, snake_direction
    snake_geometry = [
        [10, 15],
        [11, 15],
        [12, 15],
    ]
    snake_direction = [1, 0]
 
checkerboard = False

arrow_keys = [
    pyxel.KEY_UP, 
    pyxel.KEY_DOWN, 
    pyxel.KEY_LEFT, 
    pyxel.KEY_RIGHT
]

started = False

def update():
    global checkerboard, snake_geometry, snake_direction, started
    if not started:
        if pyxel.btnp(pyxel.KEY_SPACE):
            started = True
            spawn_new_snake()
            spawn_new_fruit()
        return
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    if pyxel.btnp(pyxel.KEY_C):
        checkerboard = not checkerboard
    arrow_keys_pressed = []
    for key in arrow_keys:
        if pyxel.btnp(key):
            arrow_keys_pressed.append(key)
    for key in arrow_keys_pressed:
        if key == pyxel.KEY_UP:
            snake_direction = [0, -1]
        elif key == pyxel.KEY_DOWN:
            snake_direction = [0, 1]
        elif key == pyxel.KEY_LEFT:
            snake_direction = [-1, 0]  
        elif key == pyxel.KEY_RIGHT:
            snake_direction = [1, 0]
    snake_head = snake_geometry[-1]
    new_snake_head = [
      snake_head[0] + snake_direction[0],
      snake_head[1] + snake_direction[1]
    ]
    if new_snake_head in snake_geometry:
        started = False
    elif ( 
        new_snake_head[0] < 0 or 
        new_snake_head[0] > 29 or 
        new_snake_head[1] < 0 or 
        new_snake_head[1] > 29
        ):
        started = False
    elif new_snake_head == fruit:
        snake_geometry = snake_geometry + [new_snake_head]
        spawn_new_fruit()
    else:
        snake_geometry = snake_geometry[1:] + [new_snake_head]

def draw():
    pyxel.cls(7)
    if not started:
        pyxel.text(5, 3, "Press", 0)
        pyxel.text(5, 9, "SPACE", pyxel.frame_count % 16)
        pyxel.text(11, 15, "to", 0)
        pyxel.text(5, 21, "start", 0)
        return
    if checkerboard:
        pyxel.cls(13)
        for i in range(30):
            for j in range(30):
                if (i+j) % 2 == 0:
                    pyxel.pset(i, j, 7) 
    pyxel.pset(fruit[0], fruit[1], 8)
    for x, y in snake_geometry[:-1]:
        pyxel.pset(x, y, 3)
    head = snake_geometry[-1]
    pyxel.pset(head[0], head[1], 11)

pyxel.init(30, 30, fps=10)
pyxel.run(update, draw)
```
</Admonition>
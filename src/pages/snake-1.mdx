---
title: Le serpent
author: "[S√©bastien Boisg√©rault](mailto:Sebastien.Boisgerault@minesparis.psl.eu), 
Mines Paris -- PSL"
license: "[CC BY 4.0](https://creativecommons.org/licenses/by/4.0/)"
layout: ../layouts/MDXLayout.astro
---

export const debug = true;

import Admonition from "/src/components/Admonition.astro";
import { Image } from "astro:assets";

import snake from "/src/assets/snake.jpg";

<Image src={snake} alt="Boa constrictor by Jan Kop≈ôiva" />

Projet original par Aur√©lien Noce (aka [@ushu](https://github.com/ushu)).

{/* ## Table des mati√®res */}

## Introduction

Ce TP vous propose de d√©velopper un petit jeu en Python.
Il constitue une introduction √† la conception et √† la r√©alisation
d'un programme complet.

Son sujet est un standard du jeu vid√©o, le üêç [snake].

[[üéÆ Snake!](https://kitao.github.io/pyxel/wasm/examples/07_snake.html) ;
une version classique du snake, r√©alis√©e avec la plate-forme de retro-gaming
Python [Pyxel](https://github.com/kitao/pyxel).](images/snake-pyxel.jpg)

De nombreuses variantes de ce jeu existent ; [slither.io](https://slither.io)
est un bon exemple de snake modernis√© (et notamment, massivement multijoueur !).

[snake]: https://fr.wikipedia.org/wiki/Snake_(genre_de_jeu_vid%C3%A9o)

Rassurez-vous, notre objectif sera modeste et donc proche de la version
classique du jeu : nous r√©aliserons plusieurs versions d'un **programme qui marche**
(et pas un programme parfait) dont les fonctionnalit√©s s'enrichiront √†
chaque nouvelle √©tape.

## Getting started

Let's start with a message display whose color changes over time.

<video controls width="768">
  <source src="../videos/hello-snake.webm" type="video/webm" />
</video>

The code of this application is:

```python
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(0)
    color = pyxel.frame_count % 16
    pyxel.text(56, 54, "Hello, Snake!", color)

pyxel.init(160, 120)
pyxel.run(update, draw)
```

Now we are going to slightly tweak this program until we understand 
what's going on. 
When it's necessary, search into Pyxel's [user's guide] and [reference 
documentation].

[user's guide]: https://github.com/kitao/pyxel#how-to-uses
[reference documentation]: https://github.com/kitao/pyxel#api-reference


import palette from "/src/assets/pyxel-color-palette.png";

### Colors

Can you display the message in black on a white background instead?



<Admonition type="solution" open={debug}>
In the spirit of retro gaming, Pyxel can only display 16 colors.
The standard palette from which you must pick your color is described [here][palette].

<Image src={palette} alt="Pyxel's color palette" style="margin:auto;display:block;"/>


The index of black is `0` and there is no pure white, but the closest is color
`7`. 
Therefore, the changes we need to perform are:

[palette]: https://github.com/kitao/pyxel#color-palette


```diff
 def draw():
-    pyxel.cls(0)
+    pyxel.cls(7)
-    color = pyxel.frame_count % 16
+    color = 1
     pyxel.text(56, 54, "Hello, Snake!", color)
```
</Admonition>

[API]: https://github.com/kitao/pyxel#api-reference

### Text & Geometry

- Text: comprendre la taille (fixe) de chaque caract√®re,
  display d'une "grille" de caract√®res., comprendre comment est
  plac√© le "Hello world!", ajuster le programme pour que le texte
  soit toujours centr√© (m√™me si plusieurs lignes ?).

- Message translating from the right to the left?

### Frame rate

The `time` function from the `time` module of the Python standard library
returns the time elapsed in seconds since January 1st, 1970 at noon.

```
>>> import time
>>> time.time()
1692980870.0990813
>>> time.time()
1692980871.2445116
>>> time.time()
1692980872.3245282
```

Use this function to measure the time elapsed between two calls to the `draw`
function of Pyxel. Then, print the (approximate) number of frames per second 
(FPS) in window top left corner.

<video controls width="768">
  <source src="../videos/fps.webm" type="video/webm" />
</video>

<Admonition type="solution" open={debug}>
```diff
 import pyxel
+import time

 def update():
     if pyxel.btnp(pyxel.KEY_Q):
         pyxel.quit()

 def draw():
+    global t
+    t_new = time.time()
+    dt = t_new - t
+    t = t_new
+    fps = 1.0 / dt
+    fps = int(round(fps))
     pyxel.cls(0)
     color = pyxel.frame_count % 16
     pyxel.text(56, 54, "Hello, Snake!", color)
+    pyxel.text(0, 0, f"fps: {fps}", 7)
```
</Admonition>

## Ev√®nements

  - √©v√®nement claviers: d√©tecter les fl√®ches, afficher les symboles,
    avec ceux qui sont press√©s d'une couleur diff√©rente (plus vive).

  - √©ventuellement: "P" pour pause ? Plus rien n'est mis √† jour ?
   (sauf la d√©tection de la touche "P")

<Admonition type="solution" open={debug}>

```diff
+ARROW_KEYS = [
+    pyxel.KEY_UP, 
+    pyxel.KEY_DOWN, 
+    pyxel.KEY_LEFT, 
+    pyxel.KEY_RIGHT
+]
+
+arrow_keys_pressed = None

 def update():
+    global arrow_keys_pressed
     if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
+    arrow_keys_pressed = []
+    for key in ARROW_KEYS:
+        if pyxel.btn(key):
+            arrow_keys_pressed.append(key)
```

```python
import pyxel

ARROW_KEYS = [
    pyxel.KEY_UP, 
    pyxel.KEY_DOWN, 
    pyxel.KEY_LEFT, 
    pyxel.KEY_RIGHT
]

arrow_keys_pressed = None

def update():
    global arrow_keys_pressed
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()
    arrow_keys_pressed = []
    for key in arrow_keys_pressed:
        if pyxel.btn(key):
            arrow_keys_pressed.append(key)

def draw():
    pyxel.cls(0)
    if pyxel.KEY_UP in arrow_keys_pressed:
        color = 7
    else:
        color = 13
    pyxel.rect(10, 0, 10, 10, color)
    if pyxel.KEY_LEFT in arrow_keys_pressed:
        color = 7
    else:
        color = 13
    pyxel.rect(0, 10, 10, 10, color)
    if pyxel.KEY_DOWN in arrow_keys_pressed:
        color = 7
    else:
        color = 13
    pyxel.rect(10, 10, 10, 10, color)
    if pyxel.KEY_RIGHT in arrow_keys_pressed:
        color = 7
    else:   
        color = 13
    pyxel.rect(20, 10, 10, 10, color)

pyxel.init(30, 20)
pyxel.run(update, draw)
```
</Admonition>

## √âv√©nements

Pygame permet de sp√©cifier comment r√©agir aux actions de l'utilisateur,
par exemple son utilisation du clavier ou de la souris.

Nous pouvons ainsi faire en sorte de forcer l'arr√™t du programme lorsque
l'utilisateur clique sur le bouton de fermeture de la fen√™tre ou appuie sur
la touche Q :

```python
import random
import sys
import pygame

pygame.init()
screen = pygame.display.set_mode([300, 300])
clock = pygame.time.Clock()

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
    red = random.randint(0, 255)
    green = random.randint(0, 255)
    blue = random.randint(0, 255)
    color = [red, green, blue]
    screen.fill(color)
    pygame.display.update()
    clock.tick(1)
````

Modifier ce programme pour que lorsque l'utilisateur presse
les fl√™ches de son clavier, le programme affiche (avec la fonction `print`)
les caract√®res `‚Üê`, `‚Üë`, `‚Üí` ou `‚Üì` dans le terminal.

üóùÔ∏è Le code renvoy√© par la fl√™che vers le haut est `pygame.K_UP` par exemple.

## Le damier

Nous allons commencer par construire notre plateau de jeu ainsi :

- le plateau de jeu est d√©coup√© en 30x30 cases,

- chaque case fait 10 pixels de c√¥t√©.

Pour v√©rifier la validit√© de ce plateau de jeu,
√©crivez un programme qui dessine un damier :

{/* ![](images/damier.png) */}

üóùÔ∏è Vous pouvez utiliser la m√©thode [`pygame.draw.rect`](https://www.pygame.org/docs/ref/draw.html#pygame.draw.rect) :

```python
x = 100
y = 100
width = 30
height = 30
rect = [x, y, width, height]
red = 255
green = 0
blue = 0
color = [red, green, blue]
pygame.draw.rect(screen, color, rect)
```

<Admonition type="solution" open={debug}>
```python
import pyxel

def update():
    if pyxel.btnp(pyxel.KEY_Q):
        pyxel.quit()

def draw():
    pyxel.cls(0)
    for i in range(30):
        for j in range(30):
            if (i+j) % 2 == 0:
                pyxel.rect(i*10, j*10, 10, 10, 7) 

pyxel.init(300, 300)
pyxel.run(update, draw)
```
</Admonition>

## Un serpent fixe

> No no he's not dead, he's, he's restin'!

L'√©tape suivante est de dessiner le serpent, comme une suite de segments
repr√©sent√©s par des rectangles color√©s.
On veut dessiner le serpent aux coordonn√©es suivantes :

```python
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
```

pour obtenir un sch√©ma comme suit ;
disons pour fixer les id√©es que dans ce cas de figure `[10, 15]` est la queue
et `[12, 15]` est la t√™te :

{/* ![](images/serpent.png) */}

<Admonition type="solution" open={debug} >


```python
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
snake = [
[10, 15],
[11, 15],
[12, 15],
]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
for event in pygame.event.get():
if event.type == pygame.QUIT:
pygame.quit()
sys.exit()
elif event.type == pygame.KEYDOWN:
if event.key == pygame.K_q:
pygame.quit()
sys.exit()
screen.fill(white)
for x, y in snake:
rect = [x*20, y*20, 20, 20]
pygame.draw.rect(screen, black, rect)  
 pygame.display.update()
clock.tick(1)

````
</Admonition>


Un serpent qui bouge
--------------------------------------------------------------------------------

Ensuite, nous allons faire bouger le serpent :

- nous cr√©ons un vecteur de "direction", par exemple

  ```python
  direction = [1, 0]
  ```

- √† chaque it√©ration de la boucle, nous pouvons d√©placer le serpent dans
  cette direction en "ajoutant" ce vecteur √† la position de la t√™te du serpent

{/* ![](images/serpent-bouge.gif) */}

Une fois que le serpent bouge, ajouter les commandes pour se d√©placer dans
les 4 directions, en appuyant sur les touches de direction du clavier.

Aussi on peut commencer √† envisager d'acc√©l√©rer un peu le jeu √† ce stade ...

**Bonus.** Faites en sorte que le serpent ne puisse pas faire demi-tour.

<Admonition type="solution" open={debug} >


```python
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0.0, -1.0]
            elif event.key == pygame.K_LEFT:
                direction = [-1.0, 0.0]
            elif event.key == pygame.K_DOWN:
                direction = [0.0, 1.0]
            elif event.key == pygame.K_RIGHT:
                direction = [1.0, 0.0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    pygame.display.update()
    clock.tick(1)
```

</Admonition>

## Le fruit

Il faut maintenant faire manger notre serpent.
On va proc√©der comme suit:

- on a toujours la position du serpent dans une variable `snake` :

- on g√©n√®re un "fruit", dans une position al√©atoire

  ```python
  fruit = [10, 10]
  ```

- quand la t√™te du serpent mange le fruit,
  on place un nouveau fruit √† une position al√©atoire
  et on allonge le serpent d'une case

  {/* ![](images/manger.gif) */}

<Admonition type="solution" open={debug} >



```python
import random
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
red = [255, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]
fruit = [10, 10]

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0, -1]
            elif event.key == pygame.K_LEFT:
                direction = [-1, 0]
            elif event.key == pygame.K_DOWN:
                direction = [0, 1]
            elif event.key == pygame.K_RIGHT:
                direction = [1, 0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    if new_head == fruit:
        snake = snake + [new_head]
        fruit = [
            random.randint(0, 29),
            random.randint(0, 29)
        ]
    else:
        snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    rect = [fruit[0]*20, fruit[1]*20, 20, 20]
    pygame.draw.rect(screen, red, rect)
    pygame.display.update()
    clock.tick(1)
```

</Admonition>

## √âpilogue

Il nous reste deux petits changements pour avoir un serpent compl√®tement
fonctionnel :

- Il faut d√©tecter si le serpent se mord la queue, ou touche un
  des murs, ce qui est une condition d'√©chec.

- Enfin on peut afficher le score.
  La fa√ßon la plus simple de proc√©der est de changer le titre de la fen√™tre,
  avec la fonction `set_caption` :

  ```python
  score = 0
  pygame.display.set_caption(f"üêç Score: {score}")
  ```

<Admonition type="solution" open={debug} >




```python
import random
import sys
import pygame

white = [255, 255, 255]
black = [0, 0, 0]
red = [255, 0, 0]
snake = [
    [10, 15],
    [11, 15],
    [12, 15],
]
direction = [1, 0]
fruit = [10, 10]
score = 0

pygame.init()
screen = pygame.display.set_mode([20*30, 20*30])
clock = pygame.time.Clock()
while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_q:
                pygame.quit()
                sys.exit()
            if event.key == pygame.K_UP:
                direction = [0, -1]
            elif event.key == pygame.K_LEFT:
                direction = [-1, 0]
            elif event.key == pygame.K_DOWN:
                direction = [0, 1]
            elif event.key == pygame.K_RIGHT:
                direction = [1, 0]
    head = snake[-1]
    new_head = [
      head[0] + direction[0],
      head[1] + direction[1]
    ]
    if (
        new_head in snake
        or new_head[0] < 0
        or new_head[0] >= 30
        or new_head[1] < 0
        or new_head[1] >= 30
    ):
        pygame.quit()
        sys.exit()
    if new_head == fruit:
        score = score + 1
        snake = snake + [new_head]
        fruit = [
            random.randint(0, 29),
            random.randint(0, 29)
        ]
    else:
        snake = snake[1:] + [new_head]
    screen.fill(white)
    for x, y in snake:
        rect = [x*20, y*20, 20, 20]
        pygame.draw.rect(screen, black, rect)
    rect = [fruit[0]*20, fruit[1]*20, 20, 20]
    pygame.draw.rect(screen, red, rect)
    pygame.display.update()
    pygame.display.set_caption(f"üêç Score: {score}")
    clock.tick(1)
```

</Admonition>
